#include "Particle.h"
#include "oauth2.h"
#include "utility.h"
#include "http_status.h"

//*****************************************************************************
//
//! @brief OAuth2.0 class constructor.
//!
//! It sets the OAuth2.0 client credentials and defines the initial state of
//! the protocol by checking if the user has already authenticated the device.
//!
//!	@param[in] client_id OAuth2.0 client ID used to request user consent.
//!	@param[in] client_secret OAuth2.0 client secret used to request user consent. 
//
//*****************************************************************************
Google_OAuth2::Google_OAuth2(const String &client_id, const String &client_secret)
    : CLIENT_ID(client_id), CLIENT_SECRET(client_secret)
{
    //  If the device has not been authenticated yet (no refresh token available),
    //  then a user code will be requested to the Google servers so the user can
    //  authorize the application to use the Google APIs (access and refresh
    //  token granted).
    if (read_token())
    {
        state = OAuth2_State::REFRESH_TOKEN;
    } 
    else
    {
        state = OAuth2_State::REQ_USER_CODE;
    } 
    polling_time = 0;
    is_device_subscribed = false;
}

//*****************************************************************************
//
//! @brief Parse webhook response and error response.
//!
//!	@param[in] event Pointer to a char array holidng the webhook event info.
//!	@param[in] data Pointer to a char array holding the webhook reponse.
//!
//!	@return None.
//
//*****************************************************************************
void Google_OAuth2::parser(const char *event, const char *data)
{
    int16_t index = 0, last_index = 0;
    String str_data = String(data);
    String str_event = String(event);
    //  Get the hook type and webhook event name.
    //  i.e. event: deviceID/hook-response/oauth_usr_code/0
    //  hook: hook-response.
    //  webhook_event_name: oauth_usr_code.
    split_string(str_event, '/', index, last_index); // skip deviceID.
    String hook = split_string(str_event, '/', index, last_index);
    String webhook_event_name = split_string(str_event, '/', index, last_index);
    //  Reset the split string indexes.
    index = 0, last_index = 0;
    //  For "hook-response", the returned data is divided by '~' and varies
    //  depending on the webhook event. Integer values are  given in seconds
    //  by the Google servers and are converted to milliseconds for convenience.
    if (hook.equals("hook-response"))
    {
        if (webhook_event_name.equals(EVENT_REQ_USER_CODE))
        {
            device_code = split_string(str_data, '~', index, last_index);
            user_code = split_string(str_data, '~', index, last_index);
            auth_url = split_string(str_data, '~', index, last_index);
            life_time = split_string(str_data, '~', index, last_index).toInt() * 1000;
            polling_rate = split_string(str_data, '\0', index, last_index).toInt() * 1000;
        }
        else if (webhook_event_name.equals(EVENT_POLL_AUTH))
        {
            access_token = split_string(str_data, '~', index, last_index);
            refresh_token = split_string(str_data, '~', index, last_index);
            life_time = split_string(str_data, '\0', index, last_index).toInt() * 1000;
        }
        else if (webhook_event_name.equals(EVENT_REFRESH_TOKEN))
        {
            access_token = split_string(str_data, '~', index, last_index);
            life_time = split_string(str_data, '\0', index, last_index).toInt() * 1000;
        }
    }
    //  For "hook-error", the returned data is an error message generated by   
    //  the Particle Cloud. From this message only the HTTP status code is taken.
    //  i.e. error status 404 from www.googleapis.com
    //  HTTP status code: 404.
    else if (hook.equals("hook-error"))
    {
        http_status_code = str_data.substring(13, 16).toInt();
    }
}

//*****************************************************************************
//
//! @brief OAuth2.0 application loop.
//!
//! This is the main member function of the OAuth2.0 protocol. It uses a switch  
//! case statment to run the different steps involved in the process and 
//! also to hold the program while wating for a response. 
//!
//!	@return None.
//
//*****************************************************************************
void Google_OAuth2::loop(void)
{
    String data;
    switch (state)
    {
        case OAuth2_State::REQ_USER_CODE:
            //  1. A user code is requested from the Google Servers.
            subscribe_device_to(EVENT_REQ_USER_CODE);
            data = String::format("{\"client_id\":\"%s\"}", CLIENT_ID.c_str());
            Particle.publish(EVENT_REQ_USER_CODE, data, PRIVATE);
            Serial.println("User code request sent!");
            change_state_to(OAuth2_State::WAIT_FOR_RESPONSE);
            break;

        case OAuth2_State::POLLING_AUTH:
            //  2. Google's authorization server is polled until the user has
            //     responded to the access request or the user code has expired.
            //  To reduce the number of webhook error responses in the Particle 
            //  Console, the polling rate provided by Google (usually 5 seconds) 
            //  is doubled.
            if (millis() > (polling_time + polling_rate * 2))
            {
                polling_time = millis();
                //  If the user code expires and the user has not responded 
                //  to the access request, then the OAuth2.0 authorization 
                //  will fail.
                if (time_left())
                {
                    subscribe_device_to(EVENT_POLL_AUTH);
                    data = String::format("{\"client_id\":\"%s\",\"client_secret\":\"%s\",\"code\":\"%s\"}",
                                        CLIENT_ID.c_str(), CLIENT_SECRET.c_str(), device_code.c_str());
                    Particle.publish(EVENT_POLL_AUTH, data, PRIVATE);
                    //  Must be called to save last state.
                    change_state_to(OAuth2_State::POLLING_AUTH);
                }
                else
                {
                    Serial.println("Error: User code has expired.");
                    change_state_to(OAuth2_State::FAILED);
                }
            }
            break;

        case OAuth2_State::REFRESH_TOKEN:
            //  3. Once the access token has expired, a request is sent
            //     to refresh it. 
            subscribe_device_to(EVENT_REFRESH_TOKEN);
            data = String::format("{\"refresh_token\":\"%s\",\"client_id\":\"%s\",\"client_secret\":\"%s\"}",
                                refresh_token.c_str(), CLIENT_ID.c_str(), CLIENT_SECRET.c_str());
            Particle.publish(EVENT_REFRESH_TOKEN, data, PRIVATE);
            Serial.println("Refresh token request sent!");
            change_state_to(OAuth2_State::WAIT_FOR_RESPONSE);
            break;

        case OAuth2_State::WAIT_FOR_RESPONSE:
            Serial.println("waiting for a response...");
            delay(1000);
            break;

        default:
            break;
    }
}

//*****************************************************************************
//
//! @brief OAuth2.0 webhook response handler.
//!
//! This method is called by the OS whenever the HTTP status code received 
//! in the response is EQUAL TO 200.
//!
//!	@param[in] event Pointer to a char array holidng the webhook event info.
//!	@param[in] data Pointer to a char array holding the webhook reponse.
//
//*****************************************************************************
void Google_OAuth2::response_handler(const char *event, const char *data)
{
    //  Parse the webhook reponse.
    parser(event, data);
    switch (last_state)
    {
        case OAuth2_State::REQ_USER_CODE:
        {
            String msg = "\r\nThis application requires your permission to access your Google Calendar.";
            msg += "\r\nPlease, go to: " + auth_url;
            msg += ", and enter the following code: " + user_code + "\r\n";
            Serial.println(msg);
            change_state_to(OAuth2_State::POLLING_AUTH);
        }
        break;

        case OAuth2_State::POLLING_AUTH:
            Serial.println("\r\nDevice authorized!\r\n");
            change_state_to(OAuth2_State::AUTHORIZED);
            //  Write refresh token in memory.
            write_token();
            break;

        case OAuth2_State::REFRESH_TOKEN:
            Serial.println("\r\nAccess token refreshed!\r\n");
            change_state_to(OAuth2_State::AUTHORIZED);
            break;

        default:
            break;
    }
    //  Update time to maintain the remaining lifetime  
    //  of the user code and access token consistent.
    time = millis();
    is_device_subscribed = false;
    //  Unsubscribe all subscritptions handlers to make sure that
    //  unnecessary events are removed after the device has been authorized.
    Particle.unsubscribe();
}

//*****************************************************************************
//
//! @brief OAuth2.0 webhook error response handler.
//!
//! This method is called by the OS whenever the HTTP status code received 
//! in the response is DIFFERENT THAN 200.
//!
//!	@param[in] event Pointer to a char array holidng the webhook event info.
//!	@param[in] data Pointer to a char array holding the webhook reponse.
//
//*****************************************************************************
void Google_OAuth2::error_handler(const char *event, const char *data)
{
    //  Parse the webhook error reponse.
    parser(event, data);
    //  A string object is built with the HTTP status code 
    //  and an error message to infrom the user.
    http_error = String::format("\r\nHTTP ERROR - %d", http_status_code);
    switch (last_state)
    {
        case OAuth2_State::REQ_USER_CODE:
            http_error = "\r\nError: Invalid client id.";
            break;

        case OAuth2_State::POLLING_AUTH:
            //  Google's authorization server returns HTTP_PRECONDITION_REQUIRED (428)
            //  to indicate that the user has not authenticated the application yet. 
            //  This is treated as an error by the Particle Cloud, but it is not for the 
            //  application. So the requesting device should continue sending polling 
            //  requests until it receives a response, indicating that the user has 
            //  responded to the access request.   
            if (http_status_code == HTTP_PRECONDITION_REQUIRED)
            {
                Serial.println("Authorization pending...");
            }
            else if (http_status_code == HTTP_FORBIDDEN)
            {
                http_error += "\r\nError: Access denied.";
            }
            else if (http_status_code == HTTP_UNAUTHORIZED)
            {
                http_error += "\r\nError: Invalid client secret.";
            }
            else if (http_status_code > 0)
            {
                http_error += "\r\nError: Invalid request.";
            }
            break;

        case OAuth2_State::REFRESH_TOKEN:
            //  Refresh token is erased from memory  
            //  if the device fails to refresh the access token.  
            erase_token();
            http_error += "\r\nError: Invalid request.";
            break;

        default:
            break;
    }
    //  OAuth2.0 authorization fails for any HTTP status code different than 428.
    //  Also, the Particle Cloud sends "sleep responses" if too many errors are 
    //  generated within a short period of time. To avoid them always check for
    //  HTTP status codes greater than zero.
    if (http_status_code > 0 && http_status_code != HTTP_PRECONDITION_REQUIRED)
    {
        Serial.println(http_error);
        change_state_to(OAuth2_State::FAILED);
    }
}

//*****************************************************************************
//
//! @brief Change the current OAuth2.0 state.
//!
//! This method changes the current OAuth2.0 state and saves the last one
//! to handle webhook reponses from past states.
//!
//!	@param[in] new_state OAuth2.0 state assigned to the current state.
//!
//!	@return None.
//
//*****************************************************************************
void Google_OAuth2::change_state_to(OAuth2_State new_state)
{
    last_state = state;
    state = new_state;
}

//*****************************************************************************
//
//! @brief Subscribes the device to a Particle webhook event.
//!
//! This method subscribes the device to a customized webhook response and 
//! error response event name. The device ID is included in the customized
//! event name so only THIS device will get the response.
//!
//!	@param[in] event Webhook event name used to subscribe the device.
//!
//!	@return None.
//
//*****************************************************************************
void Google_OAuth2::subscribe_device_to(const String &event)
{
    if (!is_device_subscribed)
    {
        //  According to the Argon device OS API, a max of 4 handlers
        //  are supported per device. For OAuth2.0 there are 3 webhooks,
        //  each with 2 handlers; in total, 6 handler are required.
        //  Because of this, before calling Particle.subscribe(), ALL previous
        //  subscriptions are removed by calling Particle.unsubscribe().
        Particle.unsubscribe();
        String hook_reponse = System.deviceID() + "/hook-response/" + event;
        String hook_error = System.deviceID() + "/hook-error/" + event;
        Particle.subscribe(hook_reponse, &Google_OAuth2::response_handler, this, MY_DEVICES);
        Particle.subscribe(hook_error, &Google_OAuth2::error_handler, this, MY_DEVICES);
        is_device_subscribed = true;
    }
}

//*****************************************************************************
//
//! @brief Calculate the remaning lifetime of the access token/user code.
//!
//! This method calculates how much time the access token/user code
//! have left before expiring.
//!
//! @return false if no time left, true if there is still time left.
//
//*****************************************************************************
bool Google_OAuth2::time_left(void)
{
    uint32_t time_elapsed = millis() - time;
    time = millis();
    life_time -= time_elapsed;
    return (life_time > 0);
}

//*****************************************************************************
//
//! @brief Check if the application has been authenticated already.
//!
//! @return false if not authenticated, true if authenticated.
//
//*****************************************************************************
bool Google_OAuth2::authenticated(void)
{
    return state == OAuth2_State::REFRESH_TOKEN;
}

//*****************************************************************************
//
//! @brief Check if the access token is still valid.
//!
//! @return false if not valid, true if valid.
//
//*****************************************************************************
bool Google_OAuth2::is_token_valid(void)
{
    if (time_left()) 
    {
        return true;   
    }
    //  Current state is changed to refresh the access token.
    state = OAuth2_State::REFRESH_TOKEN;
    return false;
}

//*****************************************************************************
//
//! @brief Check if the application has been authorized.
//!
//! @return false if not authorized, true if authorized.
//
//*****************************************************************************
bool Google_OAuth2::authorized(void)
{
    return state == OAuth2_State::AUTHORIZED;
}

//*****************************************************************************
//
//! @brief Check if the OAuth2.0 authorization failed.
//!
//! @return false if did not fail, true if failed.
//
//*****************************************************************************
bool Google_OAuth2::failed(void)
{
    return state == OAuth2_State::FAILED;
}

//*****************************************************************************
//
//! @brief Print the HTTP error response returned by the last event published.
//!
//! @return None.
//
//*****************************************************************************
void Google_OAuth2::print_error(void)
{
    Serial.println(http_error);
}

//*****************************************************************************
//
//! @brief Write refresh token to memory.
//!
//! This method writes the OAuth2.0 refresh token in the EEPROM.
//!
//! @return None.
//
//*****************************************************************************
void Google_OAuth2::write_token(void)
{
    char token[TOKEN_LENGTH];
    //  Convert the refresh token from an string object to a char array.
    refresh_token.toCharArray(token, TOKEN_LENGTH);
    //  Write 0 to indicate "available".
    Refresh_Token.available = 0;
    //  Copy the token into the Refresh Token struct.
    strlcpy_P(Refresh_Token.data, token, sizeof(Refresh_Token.data));
    EEPROM.put(TOKEN_ADDRESS, Refresh_Token);
}

//*****************************************************************************
//
//! @brief Read refresh token from memory.
//!
//! This method reads the OAuth2.0 refresh token from the EEPROM.
//!
//! @return false if token not available, true if token available.
//
//*****************************************************************************
bool Google_OAuth2::read_token(void)
{
    EEPROM.get(TOKEN_ADDRESS, Refresh_Token);
    //  If 1, token not available in memory.
    //  If 0, token available in memory.
    if (Refresh_Token.available == 1)
    {
        return false;
    }
    //  Access the raw token data from the Refresh Token struct
    //  and convert it into an string object.
    refresh_token = String(Refresh_Token.data);
    return true;
}

//*****************************************************************************
//
//! @brief Erase refresh token from memory.
//!
//! This method disable use of the OAuth2.0 refresh token. It sets 
//! the "available" filed to indicate that there is no token in memory.
//! By doing this, the application will request a new refresh token. 
//!
//! @return None.
//
//*****************************************************************************
void Google_OAuth2::erase_token(void)
{
    //  Write 1 to indicate "not available".
    Refresh_Token.available = 1;
    EEPROM.put(TOKEN_ADDRESS, Refresh_Token);
}
